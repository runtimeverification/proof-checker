;; fst :: (a, b) -> a
!(def fst (lambda (pair)
            (car pair)))

;; snd :: (a, b) -> b
!(def snd (lambda (pair)
            (car (cdr pair))))

;; trd :: (a, b, c) -> c
!(def trd (lambda (triple)
            (car (cdr (cdr triple)))))

;; fth :: (a, b, c, d) -> d
!(def fth (lambda (quadruple)
            (car (cdr (cdr (cdr quadruple))))))

; f :: [stack] -> [memory] -> [claims] -> [instruction]
;   -> ([stack] -> [memory] -> [claims])
; buffer :: [instruction]
;; map :: f -> [stack] -> [memory] -> [claims] -> [instruction]
;     -> ([stack] -> [memory] -> [claims] -> [instruction])
!(defrec map (lambda (f stack memory claims buffer)
                (if (eq buffer nil)
                    (cons stack (cons memory (cons claims (cons buffer nil))))
                    (let ((result (f stack memory claims buffer)))
                         (map f (fst result) (snd result) (trd result) (fth result))))))


;; This function is used to get the value of a key in a pattern.
;; get:: key -> [a] -> value
!(defrec get (lambda (key pattern)
                (if pattern
                    (if (eq key (car pattern))
                        (car (cdr pattern))
                        (get key (cdr pattern)))
                    nil)))

;; This function is used to set a the value of a key in a pattern.
;; set :: key -> value -> [a] -> [a]
!(def set (lambda (key value pattern)
             (letrec ((aux (lambda (acc pattern)
                             (if pattern
                                 (if (eq key (car pattern))
                                     (aux (cons key (cons value acc))
                                          (cdr (cdr pattern)))
                                     (aux (cons (car pattern)
                                                (cons (car (cdr pattern)) acc))
                                          (cdr (cdr pattern))))
                                 acc))))
               (aux () pattern))))

;; This function is used to update the value with a function that consumes the
;; current value of a key in a pattern.
;; update :: key -> (value -> value) -> [a] -> [a]
!(def update (lambda (key update-fn pattern)
                (letrec ((aux (lambda (acc pattern)
                                (if pattern
                                    (if (eq key (car pattern))
                                        (aux (cons key (cons (update-fn (car (cdr pattern))) acc))
                                             (cdr (cdr pattern)))
                                        (aux (cons (car pattern)
                                                   (cons (car (cdr pattern)) acc))
                                             (cdr (cdr pattern))))
                                    acc))))
                  (aux () pattern))))

;; This function is used to check if a list contains an element
;; contains :: ele -> [a] -> bool
!(defrec contains (lambda (ele list)
                     (if list
                         (if (eq ele (car list))
                             t
                             (contains ele (cdr list)))
                         nil)))

;; This function is used to check if list2 contains any element in list1
!(defrec containsElement
    (lambda (list1 list2)
       (if list1
           (if (contains (car list1) list2)
               t
               (containsElement (cdr list1) list2))
           nil)))

;; logical and
!(def and (lambda (cond1 cond2)
             (if cond1
                 cond2
                 nil)))

;; logical or
!(def or (lambda (cond1 cond2)
            (if cond1
                t
                cond2)))

;; logical not
!(def not (lambda (cond)
             (if cond
                 nil
                 t)))
                 
;; nth :: int -> [a] -> a
!(defrec nth (lambda (n list)
            (if (eq n 0)
                (car list)
                (nth (- n 1) (cdr list)))))
