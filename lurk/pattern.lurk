
!(load "basic_operations.lurk")

;; Lurk's Pattern definition
!(def Pattern '((
  ;; Ints
  :inst 0               ; All
  :id 0                 ; EVar, SVar, Symbol, Mu, Exists, MetaVar
                        ; ESubst (evar_id), SSubst (svar_id)
  ;; IdLists
  :e_fresh nil          ; MetaVar
  :s_fresh nil          ; MetaVar
  :positive nil         ; MetaVar
  :negative nil         ; MetaVar
  :app_ctx_holes nil    ; MetaVar
  
  ;; Patterns
  :left nil             ; Implication, Application   
  :right nil            ; Implication, Application
  :subpattern nil       ; Exists, Mu, ESubst (pattern), SSubst (pattern)
  :plug nil             ; ESubst, SSubst
  ))
)

;; Definition: metavar_unconstrained(new_id) = Pattern{inst = 9, id = new_id}
;; Use: !(def new_metavar_unconstrained (metavar_unconstrained new_id))
!(def metavar_unconstrained 
    (lambda (new_id) 
        (set :inst 9 
        (set :id new_id (car Pattern))
        )
    )
)

;; Definition: metavar(new_id, e_fresh, s_fresh, positive, negative, app_ctx_holes) = Pattern{inst = 10, id = new_id, e_fresh = e_fresh, s_fresh = s_fresh, positive = positive, negative = negative, app_ctx_holes = app_ctx_holes}
;; Use: !(def new_metavar (metavar new_id e_fresh s_fresh positive negative app_ctx_holes))
!(def metavar 
    (lambda (new_id e_fresh s_fresh positive negative app_ctx_holes) 
        (set :inst 9 
        (set :id new_id 
        (set :e_fresh e_fresh 
        (set :s_fresh s_fresh 
        (set :positive positive 
        (set :negative negative 
        (set :app_ctx_holes app_ctx_holes (car Pattern))
        ))))))
    )
)

;; Definition: metavar_s_fresh(new_id, s_fresh, positive, negative) = Pattern{inst = 11, id = new_id, s_fresh = (s_fresh nil), positive = positive, negative = negative}
;; Use: !(def new_metavar_s_fresh (metavar_s_fresh new_id s_fresh positive negative))
!(def metavar_s_fresh 
    (lambda (new_id s_fresh positive negative) 
        (set :inst 9 
        (set :id new_id 
        (set :s_fresh (cons s_fresh nil) 
        (set :positive positive 
        (set :negative negative (car Pattern))
        ))))
    )
)

;; Definition: implies(p1, p2) = Pattern{inst = 5, left = p1, right = p2}
;; Use: !(def new_implies (implies p1 p2))
!(def implies 
    (lambda (p1 p2) 
        (set :inst 5 
        (set :left p1 
        (set :right p2 (car Pattern))
        ))
    )
)

